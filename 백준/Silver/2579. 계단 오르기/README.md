# [Silver III] 계단 오르기 - 2579 

[문제 링크](https://www.acmicpc.net/problem/2579) 

### 성능 요약

메모리: 32412 KB, 시간: 40 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2025년 3월 23일 23:47:28

### 문제 설명

<p>계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://u.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/Screen%20Shot%202021-06-23%20at%203.00.46%20PM.png" style="width: 300px; height: 160px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.</p>

<p style="text-align: center;"><img alt="" src="https://u.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/Screen%20Shot%202021-06-23%20at%203.01.39%20PM.png" style="width: 300px; height: 190px;"></p>

<p style="text-align: center;"><그림 2></p>

<p>계단 오르는 데는 다음과 같은 규칙이 있다.</p>

<ol>
	<li>계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.</li>
	<li>연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.</li>
	<li>마지막 도착 계단은 반드시 밟아야 한다.</li>
</ol>

<p>따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.</p>

<p>각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>입력의 첫째 줄에 계단의 개수가 주어진다.</p>

<p>둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.</p>

### 출력 

 <p>첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.</p>


## 문제 해결 아이디어

계단이 최대 300개이고, 계단의 수가 늘어날수록 기하급수적으로 경우의 수가 증가하기 때문에, DP를 이용해서 문제를 풀면 간단해진다.   

계단의 점수를 담은 stair 리스트   

점수의 합을 담을 dp 리스트. dp는 마지막 계단의 입장에서 이전 계단들이 어떻게 밟힐지 생각해볼 수 있다.   

두 가지의 경우가 있다.   

1. 마지막 계단의 전 계단을 밟은 경우 (6개의 계단인 경우, 6, 5를 밟는다.)
2. 마지막 계단의 전 계단을 밟지 않는 경우 (6, 4, 3를 밟는다.)

점화식으로 표현하면,

1. stair[i] + stair[i-1] + dp[i-3]: 경우1
2. stair[i] + dp[i-2]: 경우2

```python
max(stair[i] + stair[i-1] + dp[i-3], stair[i] + dp[i-2])
```
## 최종 코드

```python
n = int(input())
stair = [0]
for i in range(n):
    stair.append(int(input()))

dp = [0] * (n + 1)
if n == 1:
    print(stair[1])
    exit(0)
elif n == 2:
    print(stair[1] + stair[2])
    exit(0)

elif n >= 3:
    dp[1] = stair[1]
    dp[2] = stair[1] + stair[2]
    dp[3] = max(stair[1] + stair[3], stair[2] + stair[3])
if n >= 4:
    for i in range(4, n + 1):
        dp[i] = max(stair[i]+stair[i-1]+dp[i-3], stair[i]+dp[i-2])

print(dp[n])

```
