# [Silver III] 퇴사 - 14501 

[문제 링크](https://www.acmicpc.net/problem/14501) 

### 성능 요약

메모리: 32544 KB, 시간: 36 ms

### 분류

다이나믹 프로그래밍, 브루트포스 알고리즘

### 제출 일자

2026년 2월 18일 03:43:53

### 문제 설명

<p>상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.</p>

<p>오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.</p>

<p>백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.</p>

<p>각각의 상담은 상담을 완료하는데 걸리는 기간 T<sub>i</sub>와 상담을 했을 때 받을 수 있는 금액 P<sub>i</sub>로 이루어져 있다.</p>

<p>N = 7인 경우에 다음과 같은 상담 일정표를 보자.</p>

<table class="table table-bordered">
	<thead>
		<tr>
			<th> </th>
			<th>1일</th>
			<th>2일</th>
			<th>3일</th>
			<th>4일</th>
			<th>5일</th>
			<th>6일</th>
			<th>7일</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>T<sub>i</sub></th>
			<td>3</td>
			<td>5</td>
			<td>1</td>
			<td>1</td>
			<td>2</td>
			<td>4</td>
			<td>2</td>
		</tr>
		<tr>
			<th>P<sub>i</sub></th>
			<td>10</td>
			<td>20</td>
			<td>10</td>
			<td>20</td>
			<td>15</td>
			<td>40</td>
			<td>200</td>
		</tr>
	</tbody>
</table>

<p>1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.</p>

<p>상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.</p>

<p>또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.</p>

<p>퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.</p>

<p>상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 T<sub>i</sub>와 P<sub>i</sub>가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ T<sub>i</sub> ≤ 5, 1 ≤ P<sub>i</sub> ≤ 1,000)</p>

### 출력 

 <p>첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.</p>

## 문제 해결 아이디어

들어오는 상담일과 상담비를 하나의 리스트로서 전체 상담 리스트에 저장.   

ex. [[3, 10], [5, 20], [1, 10], …]   

1일부터 시작한 경우 가능한 상담비를 저장,   
2일부터 시작한 경우 가능한 상담비를 저장,   
3일부터 시작한 경우 가능한 상담비를 저장, … 하는 식으로 하여    
각 모든 경우 중 max를 출력하면 최대 상담비가 될 것이다.   

즉, 현재 날짜에서 상담이 가능하면   
무조건 선택하고   
상담 끝나는 날로 점프한다.   

## Input 반례 (해결 과정)

```python
import sys
n = int(sys.stdin.readline())
consults = [[0, 0]]  # 상담기간, 수익
for _ in range(n):
    consults.append(list(map(int, sys.stdin.readline().split())))
fee = []
for i in range(1, n+1):
    tmpfee = 0
    available = i # 상담 시작 날짜
    while available + consults[available][0] <= n + 1:
        tmpfee += consults[available][1]
        available += consults[available][0]
        if available > n:
            break
    fee.append(tmpfee)
print(max(fee))
```

이게 왜… 틀리지..?   

반례를 찾았다.   

```
9
3 10
2 10
3 10
5 50
5 100
3 20
5 100
3 15
1 1
```

# answer : 110   

dp(bottom-up)로 문제 풀다가 중간에 있는 값을 처리해줘야 하는 상황을 처리해주지 않아서 100으로 잘못된 출력을 뱉었다. 즉,   

- 디버깅
    
    ```
    1 상담시작: 1  상담기간: 3  수익: 10
    1 상담시작: 4  상담기간: 5  수익: 50
    1 상담시작: 9  상담기간: 1  수익: 1
    
    2 상담시작: 2  상담기간: 2  수익: 10
    2 상담시작: 4  상담기간: 5  수익: 50
    2 상담시작: 9  상담기간: 1  수익: 1
    
    3 상담시작: 3  상담기간: 3  수익: 10
    3 상담시작: 6  상담기간: 3  수익: 20
    3 상담시작: 9  상담기간: 1  수익: 1
    
    4 상담시작: 4  상담기간: 5  수익: 50
    4 상담시작: 9  상담기간: 1  수익: 1
    
    **5 상담시작: 5  상담기간: 5  수익: 100**
    
    6 상담시작: 6  상담기간: 3  수익: 20
    6 상담시작: 9  상담기간: 1  수익: 1
    
    9 상담시작: 9  상담기간: 1  수익: 1
    
    100
    ```
    

5일에 걸리지 않는, 5일 전에 있는 상담도 할 수 있는데, 5일부터만 세버려서 100으로만 출력이 된 것이다. (첫번째 날이나 2번째 날은 상담 가능)   

<aside>
💡

1일부터 탐색:   

상담이 가능하다면 / 상담을 안 할 수도, 상담을 할 수도 있다는 걸 고려하지 않았다.   

</aside>

그렇다면 뒤에서부터 탐색을 해서 상담을 한 경우와 하지 않은 경우 중 더 큰 걸 선택하자! ~~(라고 llm의 도움을 받아 도출….후ㅜ 하지만 코드는 직접 짜보자)~~    

`dp[i]`를 `i일째부터 퇴사일까지 벌 수 있는 최대 수익`으로 정의하자.   

```python
dp[1] = 1일부터 끝까지 최대 수익
dp[2] = 2일부터 끝까지 최대 수익
...
dp[n]
```

아래 점화식에 의해 계산 순서는 dp[n]부터 dp[1]로 진행해야 한다.    

```python
dp[i] =
    max(
        dp[i+1],             # 오늘 상담 안 함
        P[i] + dp[i+T[i]]    # 오늘 상담 함
    )
```

dp[i]가 dp[i+1]인 경우는 i일부터 최대 수익이 i일은 아무것도 안 하고   
i+1일부터 최대 수익인 경우이다. (즉, i일에 상담 안 한 경우, i+1부터 최대 수익)   

## 최종 코드

```python
import sys
n = int(sys.stdin.readline())
consults = [[0, 0]]  # 상담시작일, 수익
for _ in range(n):
    consults.append(list(map(int, sys.stdin.readline().split())))
dp = [0] * (n + 2)  # dp[i] = i일부터 퇴사일까지 벌 수 있는 최대 수익

for i in range(n, 0, -1):
    if i + consults[i][0] > n + 1:  # 오늘 상담이 퇴사일을 넘기는 경우
        dp[i] = dp[i+1]   # 오늘 수익이 없어 내일의 최대값을 가져옴.
    else:  # 오늘 상담이 퇴사일을 넘기지 않는 경우
        # 오늘 상담을 하지 않는 경우와 하는 경우 중 최대값을 가져옴.
        dp[i] = max(dp[i+1], consults[i][1] + dp[i+consults[i][0]])

print(dp[1])
```
