# [level 2] 짝지어 제거하기 - 12973 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12973) 

### 성능 요약

메모리: 14.8 MB, 시간: 85.30 ms

### 구분

코딩테스트 연습 > 2017 팁스타운

### 채점결과

정확성: 61.2<br/>효율성: 38.8<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 11월 17일 22:35:49

### 문제 설명

<p>짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.</p>

<p>예를 들어, 문자열 S = <code>baabaa</code> 라면</p>

<p>b <em>aa</em> baa → <em>bb</em> aa → <em>aa</em> →</p>

<p>의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.</p>

<h5>제한사항</h5>

<ul>
<li>문자열의 길이 : 1,000,000이하의 자연수</li>
<li>문자열은 모두 소문자로 이루어져 있습니다.</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>s</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>baabaa</td>
<td>1</td>
</tr>
<tr>
<td>cdcd</td>
<td>0</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
위의 예시와 같습니다.<br>
입출력 예 #2<br>
문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.</p>

<p>※ 공지 - 2020년 6월 8일 테스트케이스가 추가되었습니다.<br>
※ 공지 - 2023년 8월 31일 테스트케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수도 있습니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

## 문제 해결 아이디어

입력받은 문자열 s를 글자별로 분리하여 list로 저장하고, i번째 요소와 i+1번째 요소가 같으면 stack에 두 인덱스를 넣고, 해당 두 글자를 건너뛰고 비교한다. 같지 않을 시 i번째 인덱스 요소만 건너뛰고 다시 비교한다.    

인덱스를 다 탐색하면, stack을 내림차순으로 정렬하고 저장된 인덱스 요소를 삭제하고 stack을 비운다.    

이를 s의 길이보다 많이 반복하거나 s가 다 없어지면 반복을 멈춘다.    

## Input 반례 (해결 과정)   

```python
def solution(s):
    s = list(s)
    stack = []
    count = 0
    while (1):
        if count > len(s)//2 or len(s)==0:
            break
        stack.clear()
        i = 0
        while i < len(s)-1:
            if i+1 < len(s):
                if s[i]==s[i+1]:
                    stack.append(i)
                    stack.append(i+1)
                    i += 1
                i+=1
        count += 1
        stack.sort()
        for j in reversed(stack):
            del s[j]
        
    if not s: # 모두 제거 가능
        return 1
    return 012973 
```

위 처럼 코드를 작성하였는데 문자열의 길이가 최대 1,000,000이고 반복문이 중첩되어 시간초과가 발생한 것으로 보인다.     
특히 `while i < len(s)-1:` 내부에서 `stack.append()`와 `del` 연산을 반복적으로 수행하고 있으며, `del s[j]`는 리스트의 요소를 삭제하므로 리스트의 길이에 비례하는 시간 복잡도를 가진다.     
</br>

**리스트 del의 비효율성**    

파이썬에서 리스트는 연결 리스트가 아니라 배열 기반이다. 따라서 `del s[j]` 연산은 해당 인덱스 이후의 모든 요소를 한 칸씩 이동해야 하므로 O(n)의 시간 복잡도가 발생한다.    

만약 문자열의 길이가 n이라면, 최악의 경우 리스트 요소를 n번 삭제해야 하므로 최종 시간 복잡도는 O(n^2)에 가까워진다.    
</br>

**불필요한 스택 정렬**    

`stack.sort()`는 매 반복마다 스택을 정렬하고 있지만, `while i < len(s)-1:`에서 쌍을 탐지한 순서대로 제거할 수 있다. 굳이 정렬하지 않아도 되며, 오히려 이로 인해 추가적인 O(k log k) 시간 복잡도가 발생한다 (`k`는 스택의 길이).    
</br>

**불필요한 루프 반복**      

`while (1):` 루프는 문자열의 길이가 짧아지거나 `count > len(s) // 2` 조건을 만족하면 종료된다. 그러나 `while i < len(s)-1:` 내부에서 이미 많은 작업을 처리하므로 `while (1):`의 필요성이 낮은 걸로 보인다.         

따라서 stack을 사용하면 같은 문자를 push와 pop 할 수 있다.         

비어있는 스택을 생성한다.       

입력받은 문자열 만큼 반복하면서, 현재 문자와 stack의 맨 위가 같으면 pop하고, 같지 않으면 현재 문자를 stack에 push 한다. 문자열을 모두 순회하고 stack이 비어있으면 1, 아니면 0을 반환하면 된다.    

문자열의 크기가 커져도 연산은 O(n)만큼의 시간이 소요되어 시간 초과가 발생하지 않게 된다.        

## 최종 코드

```python
def solution(s):
    stack = []  # 비어 있는 스택 생성
    for char in s:  # 문자열 s의 각 문자를 순서대로 확인
        if stack and stack[-1] == char:  # 스택이 비어있지 않고, 스택 맨 위 문자와 현재 문자가 같으면
            stack.pop()  # 스택에서 맨 위 문자 제거 (쌍 제거)
        else:
            stack.append(char)  # 그렇지 않으면 현재 문자를 스택에 추가
    return 1 if not stack else 0  # 스택이 비어 있으면 1, 아니면 0 반환

```
