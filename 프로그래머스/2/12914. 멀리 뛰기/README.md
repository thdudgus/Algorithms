# [level 2] 멀리 뛰기 - 12914 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12914) 

### 성능 요약

메모리: 10.2 MB, 시간: 0.39 ms

### 구분

코딩테스트 연습 > 연습문제

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 11월 03일 20:12:20

### 문제 설명

<p>효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는<br>
(1칸, 1칸, 1칸, 1칸)<br>
(1칸, 2칸, 1칸)<br>
(1칸, 1칸, 2칸)<br>
(2칸, 1칸, 1칸)<br>
(2칸, 2칸)<br>
의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.</p>

<h5>제한 사항</h5>

<ul>
<li>n은 1 이상, 2000 이하인 정수입니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>n</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
위에서 설명한 내용과 같습니다.</p>

<p>입출력 예 #2<br>
(2칸, 1칸)<br>
(1칸, 2칸)<br>
(1칸, 1칸, 1칸)<br>
총 3가지 방법으로 멀리 뛸 수 있습니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

## 문제 해결 아이디어

1칸으로 이루어진 경우는 무조건 가능하기 때문에 count를 1로 초기화하고 시작한다.   

그리고 i를 2칸의 개수로 설정한다. i가 1부터 n//2번 for문을 반복하면서, math.comb(n-i, i) 또는 math.comb(i, n-i)를 count에 더해준다.    

## Input 반례 (해결 과정)

```python
import math

def solution(n):
    answer = 1  # 1번씩 뛸 때
    for i in range(1, (n // 2) + 1):  # i는 2의 개수
        temp = math.comb(n - i, i)
        answer += temp
    return answer
```

위 코드로 실행했을 때 테스트 코드는 정답이지만, 런타임에러가 발생된다.    

n값이 커지면 `math.comb()` 에서 계산할 수 없는 큰 수가 발생하는 것이 문제가 될 수 있다고 한다.    

<aside>
💡

⇒ 동적 프로그래밍을 활용해야 한다!    

</aside>

n칸이 있을 때, 1칸 또는 2칸을 뛰는 모든 경우의 수를 구해야 한다.     

주어진 n에 도달하는 방법을 찾기 위해 n 이전 단계에서의 경우의 수를 활용한다. 각 단계에서 1칸 또는 2칸을 뛰는 방법만 허용되기 때문에, n칸을 가는 경우는 두 가지이다.    

1. 마지막에 1칸 뛰기 :  n-1 위치에서 1칸을 뛰어서 n에 도달하는 경우   
2. 마지막에 2칸 뛰기 : n-2 위치에서 2칸을 뛰어서 n에 도달하는 경우   
    
    위 경우는 해당 예시로 설명 가능하다. n이 4일 때, 마지막에 어떤 식으로든 4에 도달해야 한다.     
    
    1. n-1인 3 위치에 이미 도달한 상태에서 마지막 1칸을 뛰어 n=4에 도달하는 경우   
    2. n-2인 2 위치에 이미 도달한 상태에서 마지막 2칸을 뛰어 n=4에 도달하는 경우     

따라서 **n에 도달하는 방법은 n-1번째 칸에서 오는 경우의 수와 n-2번째 칸에서 오는 경우의 수를 더한 값이 된다.**     

```python
def solution(n):
    longJump = []
    longJump.append(1)
    longJump.append(1)
    for i in range(2, n+1):
        longJump.append(longJump[i-1] + longJump[i-2])
        answer = longJump[i]
    return answer
```

답은 맞는데 계속해서 채점을 하면 런타임 에러가 발생하였다.      

감이 잡히지 않아 다른 사람들의 코드를 참고하니 n의 값이 크면 위 코드에선 int의 범위를 초과할 가능성이(overflowe) 있다고 한다. 따라서 각 단계에서 int의 범위를 초과하지 않게 된다.      

> 근데 1234567로 나누면, 범위가 그 안에서 제한되는 거니까 정답이 달라지는 게 아닌가 찾아봤는데 아닌가보다. (사실 완벽하게 이해는 못 했지만…)      
> 

1234567은 큰 소수로, 소수를 모듈로 사용하는 것은 수학적으로 일반적으로 해시 함수나 암호학적 알고리즘에서 분포를 균일하게 하는 데 도움을 준다고 한다…     
